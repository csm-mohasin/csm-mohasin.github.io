<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Hand Gesture 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; position: fixed; width: 100%; height: 100%; }
        canvas { display: block; }
        #info {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: #00ffcc; font-family: sans-serif; font-size: 14px;
            pointer-events: none; text-shadow: 1px 1px 2px #000;
        }
        video { transform: scaleX(-1); display: none; } /* মিরর ইফেক্ট */
    </style>
</head>
<body>

    <div id="info">মোবাইল ক্যামেরা সামনে ধরুন। <br> চিমটি কাটলে হার্ট শেপ হবে!</div>
    <video id="video" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles, geometry;
        const particleCount = 2000; // মোবাইলের জন্য অপ্টিমাইজড
        let currentShape = 'sphere';

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 40;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 40;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
                
                colors[i * 3] = Math.random();
                colors[i * 3 + 1] = Math.random();
                colors[i * 3 + 2] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({ 
                size: 0.25, 
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function transformShape(type) {
            const positions = geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                const idx = i * 3;

                if (type === 'heart') {
                    const angle = (i / particleCount) * Math.PI * 2;
                    x = 16 * Math.pow(Math.sin(angle), 3) * 0.6;
                    y = (13 * Math.cos(angle) - 5 * Math.cos(2 * angle) - 2 * Math.cos(3 * angle) - Math.cos(4 * angle)) * 0.6;
                    z = (Math.sin(i * 0.1)) * 2;
                } else {
                    // Sphere Logic
                    const phi = Math.acos(-1 + (2 * i) / particleCount);
                    const theta = Math.sqrt(particleCount * Math.PI) * phi;
                    x = 12 * Math.cos(theta) * Math.sin(phi);
                    y = 12 * Math.sin(theta) * Math.sin(phi);
                    z = 12 * Math.cos(phi);
                }

                positions[idx] += (x - positions[idx]) * 0.12;
                positions[idx + 1] += (y - positions[idx + 1]) * 0.12;
                positions[idx + 2] += (z - positions[idx + 2]) * 0.12;
            }
            geometry.attributes.position.needsUpdate = true;
        }

        const videoElement = document.getElementById('video');
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // দ্রুত প্রসেসিং এর জন্য 0 রাখা হয়েছে
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const thumb = landmarks[4];
                const index = landmarks[8];
                const distance = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));

                if (distance < 0.06) {
                    currentShape = 'heart';
                } else {
                    currentShape = 'sphere';
                }

                particles.rotation.y += 0.02;
                // হাত নাড়ালে অবজেক্ট ঘুরবে
                particles.rotation.x = (landmarks[8].y - 0.5) * 2;
            }
            transformShape(currentShape);
        });

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 480,
            height: 640
        });
        cameraFeed.start();

        function animate() {
            requestAnimationFrame(animate);
            particles.rotation.y += 0.005;
            renderer.render(scene, camera);
        }

        initThree();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
